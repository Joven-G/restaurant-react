package main

import (
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	jwt "github.com/dgrijalva/jwt-go"

	redisConfig "github.com/jurabek/basket.api/config"
	"github.com/jurabek/basket.api/controllers"
	"github.com/jurabek/basket.api/docs"
	"github.com/jurabek/basket.api/eureka"
	"github.com/jurabek/basket.api/repositories"

	"github.com/gin-gonic/gin"
	"github.com/gomodule/redigo/redis" // swagger embed files

	// docs is generated by Swag CLI, you have to import it.
	ginSwagger "github.com/swaggo/gin-swagger"   // gin-swagger middleware
	"github.com/swaggo/gin-swagger/swaggerFiles" // swagger embed files
)

// @title Basket API
// @version 1.0
// @description This is a rest api for basket which saves items to redis server
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @securitydefinitions.oauth2.implicit OAuth2Implicit
// @authorizationurl http://localhost:8080/identity/oauth/authorize
// @scope.basket-api
func main() {
	os.Setenv("PORT", "5050")
	gin.SetMode(gin.DebugMode)

	handleSigterm()
	router := gin.Default()
	router.Use(requestMiddleware())

	redisPool, err := initRedis()

	if err != nil {
		fmt.Print(err)
	}

	basketRepository := repositories.NewRedisBasketRepository(redisPool)
	controller := controllers.NewBasketController(basketRepository)

	api := router.Group("/api/v1/")
	{
		basket := api.Group("items")
		{
			basket.GET(":id", controller.Get)
			basket.POST("", controller.Create)
		}
	}

	// Home page should be redirected to swagger page
	router.GET("/", func(c *gin.Context) {
		c.Redirect(http.StatusMovedPermanently, "/swagger/index.html")
	})

	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	go eureka.Register()

	router.Run()
}

func authMiddleware() {
	token, err := jwt.ParseFromRequest(req, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
			return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
		} else {
			return nil, nil
		}
	})
}

func requestMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		if forwardedPrefix := c.Request.Header["X-Forwarded-Prefix"]; forwardedPrefix != nil {
			docs.SwaggerInfo.BasePath = forwardedPrefix[0] + "/api/v1/"
			fmt.Printf("Swagger base path: %s\r\n", docs.SwaggerInfo.BasePath)
		} else {
			docs.SwaggerInfo.BasePath = "/api/v1/"
		}
		if forwardedHost := c.Request.Header["X-Forwarded-Host"]; forwardedHost != nil {
			docs.SwaggerInfo.Host = forwardedHost[0]
			fmt.Printf("Swagger host: %s\r\n", docs.SwaggerInfo.Host)
		}
		c.Next()
	}
}

func handleSigterm() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGTERM, os.Kill, os.Interrupt)
	go func() {
		<-c
		eureka.UnRegister()
		time.Sleep(10 * time.Second)
		os.Exit(0)
	}()
}

func initRedis() (*redis.Pool, error) {
	redisHost := os.Getenv("REDIS_HOST")
	if redisHost == "" {
		redisHost = ":6379"
	}
	pool := redisConfig.NewRedisPool(redisHost)
	redisConfig.CleanupHook(pool)

	err := redisConfig.HealthCheck(pool)

	return pool, err
}
